\documentclass[a4paper, 12pt, article]{memoir}
\usepackage[utf8]{inputenc}
\usepackage{hyperref}
\usepackage{indentfirst}
\usepackage{listings}
\lstset{language=C++}
\lstset{keepspaces=true}
\lstset{frame=lines}
\lstset{numbers=left}
\usepackage{caption}
\captionsetup[table]{name=Tabela}
\usepackage[brazilian]{babel}

\title{Nova - Especificação v2}
\author{Rubens Pessoa}
\date{\today}
\newcommand{\institution}{Universidade Federal de Alagoas
  \\ Instituto de Computação}
\newcommand{\department}{Ciência da Computação}

\renewcommand{\maketitlehooka}{
  \centering
  \institution\\
  \emph{\department}\\[.2cm]
  \par
  \hrulefill
  \vfill}
\renewcommand{\maketitlehookb}{\vfill}

\renewcommand{\thesection}{\arabic{section}}
\renewcommand{\thesubsection}{\thesection.\arabic{subsection}}
\makeatletter
\let\l@subsection\l@section
\let\l@section\l@chapter
\makeatother
\setsecnumdepth{subsection}

\begin{document}

\frontmatter
\begin{titlingpage}
  \maketitle
\end{titlingpage}

\tableofcontents

\mainmatter

\section{Introdução}
\label{sec:intro}
A Nova consiste em uma linguagem de propósito geral, estruturada, imperativa e fortemente tipada. Inspirada na linguagem de programação C. Cada instrução deverá terminar com um ponto e vírgula. O escopo de suas variáveis será local e será possível a criação de funções afim de melhorar a legibilidade e escritabilidade. 

\section{Conjunto de Tipo de Dados}
\label{sec:conjunto}

\subsection{Identificador}
\label{subsec:id}
Seu identificador segue a seguinte forma:
\begin{itemize}
\item Inicia-se, obrigatoriamente, com uma letra maiúscula ou minúscula.
\item Os demais caracteres podem ser letras, números ou underline.
\item Seu tamanho é ilimitado.
\item É vedada a utilização de espaços em branco.
\end{itemize}

\subsection{Comentário}
\label{subsec:comentario}
Os comentários serão indicados com o seguinte caractere ``\#''. Desta forma, o que se escrever na linha após estes caracteres será descartado.

\subsection{Inteiro}
\label{subsec:inteiro}
O tipo inteiro é declarado pela palavra reservada ``int'' seguido do identificador da
variável. Por ser uma linguagem fortemente tipada, não há coerção entre tipos. Ela denota um número inteiro e seus literais são declarado por qualquer número. As operações para este tipo estão em \ref{subsec:aritmeticos}. Exemplo:
\begin{lstlisting}
  int inteiro = 1;
\end{lstlisting}

\subsection{Ponto flutuante}
\label{subsec:float}
O tipo ponto flutuante é declarado pela palavra reservada ``float'' seguido do identificador da variável.

Um literal do tipo ponto flutuante é dado por qualquer número real separado por um ``.'' de suas casas decimais. As operações para este tipo estão em \ref{subsec:aritmeticos}.

Exemplo:
\begin{lstlisting}
  float real = 1.2;
\end{lstlisting}

\subsection{Caracteres e cadeias de caracteres}
\label{subsec:string}
O tipo string é declarado pela palavra reservada ``string'' seguido do identificador da variável. Da mesma forma serão tratados as unidades de caracteres. Seus literais são um conjunto de caracteres de tamanho mínimo 0 e tamanho máximo ilimitado e são delimitados por aspas duplas. As operações para este tipo estão em
\ref{subsec:concatenacao}.

Exemplo:
\begin{lstlisting}
  string str = ``Hello World!'';
  string character = ``A'';
\end{lstlisting}

\subsection{Boolean}
\label{subsec:booleano}
O tipo boolean é declarado usando a palavra reservada ``bool'' seguido do identificador da
variável, os únicos dois possíveis valores para a variável são ``True''
e ``False''. As operações para este tipo estão em \ref{subsec:relacionais} e
\ref{subsec:logicos}.

Exemplo:
\begin{lstlisting}
  bool flag = True;
\end{lstlisting}

\subsection{Vetores unidimensionais}
\label{subsec:array}
Os vetores unidimensionais serão tratados como listas, as quais serão declaradas
informando o tipo que será armazenado na lista com acesso aleatório, terá um identificador e um
``::'' separando o identificador do tamanho máximo da lista que consistirá de um literal ou variável do tipo inteiro.

Exemplo:
\begin{lstlisting}
  int list::3;
  string words::10;
\end{lstlisting}

\subsection{Operações suportadas}
\label{operacoes_suport}

Todos os tipos suportam as operações descritas na tabela \ref{operacoes_table} com  valores correspondentes ao seu respectivo tipo.

\begin{table}[]
\centering
\caption{Operações Suportadas}
\label{operacoes_table}
\begin{tabular}{lllll}
\textbf{Tipo}   & \textbf{Operações Suportadas}                  &  &  &  \\
int    & atribuição, aritméticos e relacionais  &  &  &  \\
float  & atribuição, aritméticos e relacionais  &  &  &  \\
string & atribuição, relacionais e concatenação &  &  & \\
boolean & atribuição, relacionais e lógicos
\end{tabular}
\end{table}

\subsection{Coerção}

A NOVA não admite coerção implítica de tipos. Para converter de qualquer tipo para string explicitamente, basta usar aspas ao redor do valor ou identificador.

\section{Conjuntos de Operadores}
\label{sec:operadores}

\subsection{Atribuição}
\label{subsec:atribuicao}
A atribuição é feita pelo operador ``='', onde do lado esquerdo é o ID da variável e do lado direito é o valor a ser
guardado. Os dois lados devem possuir o mesmo tipo, pois a linguagem não permite coerção.
Exemplo:
\begin{lstlisting}
  int variable = 10;
\end{lstlisting}

\subsection{Aritméticos}
\label{subsec:aritmeticos}
\begin{itemize}
\item ``+'': Soma dos dois operandos.
\item ``-'': Diferença dos dois operandos.
\item ``*'': Multiplicação dos dois operandos.
\item ``/'': Divisão dos dois operandos.
\item ``\%": Resto da divisão dos dois operandos.
\end{itemize}

O operador unário negativo é ``not''. Este irá negar valores aritméticos dos
números, tanto inteiro, quanto ponto flutuante.

\subsection{Relacionais}
\label{subsec:relacionais}
\begin{itemize}
\item ``=='': Igualdade entre dois operandos.
\item ``!='': Desigualdade entre dois operandos.
\item ``\textless'': Operador "menor que".
\item ``\textgreater'': Operador "maior que".
\item ``\textless='': Operador "menor ou igual que".
\item ``\textgreater='': Operador "maior ou igual que".
\end{itemize}

Exemplo:
\begin{lstlisting}
  if (a == b) {
    /* do something
  }
\end{lstlisting}

\subsection{Lógicos}
\label{subsec:logicos}
\begin{itemize}
\item not: Operador unário que nega uma expressão lógica.
\item and: Executa um ``and'' lógico.
\item or: Executa um ``or'' lógico.
\end{itemize}

Exemplo:
\begin{lstlisting}
  if (a > b or c == d) {
    /* do something
  }
\end{lstlisting}

\subsection{Concatenação de cadeias de caracteres}
\label{subsec:concatenacao}
A concatenação de cadeias de caracteres será dada pelo operador binário sobrecarregado ``+''.

\section{Precedência e Associatividade}
\label{sec:precedencia}
A Tabela \ref{tab:precedencia} mostrará a precedência e associatividade dos
operadores ordenadas decrescentemente de acordo com a precedência.
\begin{table}[h]
  \centering
  \begin{tabular}{r|r}

    Operadores & Associatividade \\
    \hline
    () & Não associativo \\
    not & Direita para a esquerda \\
    $*$ / \% & Da esquerda para a direita\\
    + - & Da esquerda para a direita \\
	\textless \textgreater & Da esquerda para a direita \\
	\textless= \textgreater= & Da esquerda para a direita \\
    == != & Da esquerda para a direita \\
    and or & Da esquerda para a direita \\
    = & Da esquerda para a direita

  \end{tabular}
  \caption{Tabela de precedência e associatividade}
  \label{tab:precedencia}
\end{table}

\section{Instruções}
\label{sec:instrucoes}
Como é uma linguagem inspirada em C, temos que seus statementes são similares e portanto são terminado sempre na presença de um ``;''.

\subsection{Estrutura condicional de uma e duas vias}
\label{sub:estruturacondicional}

\subsubsection{if, if-else}
\label{subsubsec:if}
A estrutura condicional ``if'' será sempre relacionada a uma condição lógica ou à uma variável booleana dentro de
parenteses e seu escopo será definido por chaves e ponto-virgula. O algoritmo irá executar o código contido no ``if'', se e somente se, a sua condição lógica resultar em True, em caso negativo (False), pode ser criada uma clausula ``else'', que será executada no caso de a condição lógica resultar em False.

\subsection{Estrutura iterativa com controle lógico}
\label{subsec:iterativalogico}

\subsubsection{while}
\label{subsubsec:while}
A estrutura de loop``while'' é usado como uma repetição condicional, ou seja, a repetição só irá
parar se a sua condição for falsa. Desta forma, o ``while'' será sempre relacionada a uma condição lógica ou à uma variável booleana dentro de parenteses e seu escopo será definido por chaves e finalizado com um ponto-virgula.


\subsection{Estrutura iterativa controlada por contador}
\label{subsec:iterativacontador}

\subsubsection{for}
\label{subsubsec:for}
O ``for'' será uma estrutura de repetição que receberá três parâmetros: índice,
limite e passo. Ele irá repetir o bloco de código desejado no intervalo
[\emph{índice}, \emph{limite}) variando em \emph{passo} até todo intervalo
ser passado.

\subsection{Entrada e saída}
\label{subsec:io}
Seguem as funções de input e output:

\begin{itemize}
\item readIn(identificador)
\item printOut(String string)

\end{itemize}

\subsection{Funções}
\label{subsec:function}
A NOVA não suportará sobrecarga de funções. Na declaração da função será necessário que seja definida o tipo de retorno, o nome da função e dentro de parênteses todos os parâmetros e seus respectivos tipos. Seu retorno será feito com a palavra reservada "shoot". Para chamá-la, utilizaremos o nome da função e, dentro dos parênteses, os valores que utilizaremos como parâmetros.

Exemplo:
\begin{lstlisting}
  int sumInt(int x, int y) {
    shoot x + y;
  };
  int a = sumInt(5, 2);
\end{lstlisting}

Para Arranjos unidimensionais, a passagem de parâmetros é feita por referência,
os outros tipos são por valor.

Para funções há um tipo especial chamado ``void'', em que significa que tal
função retornará nenhum tipo. Não é possível uma variável ser do tipo ``void''.

\newpage

\section{Exemplos de Códigos}
\label{sec:code}

\subsection{Alô mundo}
\label{subsec:helloworld}
\begin{lstlisting}
  void main() {
    stringOut(``Alo Mundo!'');
  };
\end{lstlisting}

\subsection{Fibonacci}
\label{subsec:fibonacci}
\begin{lstlisting}
  int fibonacci(int n) {
    int f1 = 0;
    int f2 = 1;
    int fi = 0;

    printOut(``0'');
    printOut(``, '');
    printOut(``1'');

    if (n == 0 or n == 1) {
      shoot 1;
    };

    while(fi < n) {
      fi = f1 + f2;
      f1 = f2;
      f2 = fi;
      printOut(``, ``);
      printOut(``fi'');
    };

    shoot fi;
  };

  void main() {
    int n;
    readIn(n);

    int fib = fibonacci(n);
    /* do something with fib
  };
\end{lstlisting}

\subsection{Shell sort}
\label{subsec:shelsort}
\begin{lstlisting}
  void main() {
    int size;
    readIn(size);

    int vet::size;
    for (int i = 0; i < size; i = i + 1) {
      int x;
      readIn(x);
      add(vet, x);
    };

    int value;
    int gap = 1;
    while(gap < size) {
      gap = 3 * gap + 1;
    };

    while(gap > 1) {
      gap = gap / 3;
      for (int i = gap; i < size; i = i + 1) {
        value = getValue(vet, i);
        int j = i - gap;

        while(j >= 0 and value < getValue(vet, j)) {
          setValue(vet, j + gap, getValue(vet, j));
          j = j - gap;
        };

        setValue(vet, j + gap, value);
      };
    };
  };
\end{lstlisting}
\end{document}